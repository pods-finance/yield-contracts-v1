//SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.6;

import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "../interfaces/IConfigurationManager.sol";
import "../interfaces/IVault.sol";
import "../libs/TransferUtils.sol";
import "../libs/FixedPointMath.sol";
import "../libs/DepositQueueLib.sol";
import "../mixins/Capped.sol";
import "../libs/CastUint.sol";

/**
 * @title A Vault that tokenize shares of strategy
 * @author Pods Finance
 */
contract BaseVault is IVault, Capped {
    using TransferUtils for IERC20Metadata;
    using FixedPointMath for uint256;
    using CastUint for uint256;
    using DepositQueueLib for DepositQueueLib.DepositQueue;

    IConfigurationManager public immutable configuration;
    IERC20Metadata public immutable asset;

    uint256 public currentRoundId;
    mapping(address => uint256) userShares;
    uint256 public totalShares;
    bool public isProcessingDeposits = false;

    uint256 public constant DENOMINATOR = 10000;
    uint256 public constant WITHDRAW_FEE = 100;

    DepositQueueLib.DepositQueue private depositQueue;

    mapping(address => mapping(address => uint256)) private _allowances;

    constructor(IConfigurationManager _configuration, address _asset) Capped(_configuration) {
        configuration = _configuration;
        asset = IERC20Metadata(_asset);

        // Vault starts in `start` state
        emit StartRound(currentRoundId, 0);
    }

    /** Depositor **/

    /**
     * @dev See {IVault-deposit}.
     */
    function deposit(uint256 assets, address receiver) public virtual override {
        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();
        _spendCap(previewShares(assets));

        asset.safeTransferFrom(msg.sender, address(this), assets);
        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));

        emit Deposit(receiver, assets);
    }

    /**
     * @dev See {IVault-withdraw}.
     */
    function withdraw(address owner) public virtual override {
        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();

        uint256 shares = sharesOf(owner);
        uint256 assets = _burnShares(owner, shares);

        if (msg.sender != owner) {
            _useAllowance(owner, msg.sender, shares);
        }

        _restoreCap(shares);

        // Apply custom withdraw logic
        _beforeWithdraw(shares, assets);

        uint256 fee = (assets * withdrawFeeRatio()) / DENOMINATOR;
        asset.safeTransfer(owner, assets - fee);
        asset.safeTransfer(controller(), fee);

        emit Withdraw(owner, shares, assets);
    }

    /**
     * @dev See {IVault-name}.
     */
    function name() external pure virtual override returns (string memory) {
        return "Base Vault";
    }

    /**
     * @dev See {IVault-withdrawFeeRatio}.
     */
    function withdrawFeeRatio() public view override returns(uint256) {
        return configuration.getParameter(address(this), "WITHDRAW_FEE_RATIO");
    }

    /**
     * @dev See {IVault-allowance}.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IVault-approve}.
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        if (spender == address(0)) revert IVault__ApprovalToAddressZero();

        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /**
     * @dev Outputs the amount of shares and the locked shares for a given `owner` address.
     */
    function sharesOf(address owner) public view virtual returns (uint256) {
        return userShares[owner];
    }

    /**
     * @dev Outputs the amount of shares that would be generated by depositing `assets`.
     */
    function previewShares(uint256 assets) public view virtual returns (uint256) {
        uint256 shares = assets;

        if (totalShares > 0) {
            shares = assets.mulDivUp(totalShares, totalAssets());
        }

        return shares;
    }

    /**
     * @dev Outputs the amount of underlying tokens would be withdrawn with a given amount of shares.
     */
    function previewWithdraw(uint256 shares) public view virtual returns (uint256) {
        return shares.mulDivDown(totalAssets(), totalShares);
    }

    /**
     * @dev Calculate the total amount of assets under management.
     */
    function totalAssets() public view virtual returns (uint256) {
        return asset.balanceOf(address(this));
    }

    /**
     * @dev Outputs the amount of asset tokens of an `owner` is idle, waiting for the next round.
     */
    function idleBalanceOf(address owner) public view virtual returns (uint256) {
        return depositQueue.balanceOf(owner);
    }

    /**
     * @dev Outputs the amount of asset tokens is idle, waiting for the next round.
     */
    function totalIdleBalance() public view virtual returns (uint256) {
        return depositQueue.totalDeposited;
    }

    /**
     * @dev Outputs current size of the deposit queue.
     */
    function depositQueueSize() external view returns (uint256) {
        return depositQueue.size();
    }

    /** Vault Controller **/

    modifier onlyController() {
        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();
        _;
    }

    /**
     * @dev See {IVault-controller}.
     */
    function controller() public view returns(address) {
        return configuration.getParameter(address(this), "VAULT_CONTROLLER").toAddress();
    }

    /**
     * @dev Starts the next round, sending the idle funds to the
     * strategy where it should start accruing yield.
     */
    function startRound() public virtual onlyController {
        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();

        isProcessingDeposits = false;

        uint256 idleBalance = asset.balanceOf(address(this));
        _afterRoundStart(idleBalance);

        emit StartRound(currentRoundId, idleBalance);
    }

    /**
     * @dev Closes the round, allowing deposits to the next round be processed.
     * and opens the window for withdraws.
     */
    function endRound() public virtual onlyController {
        if(isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();

        isProcessingDeposits = true;
        _afterRoundEnd();

        emit EndRound(currentRoundId++);
    }

    /**
     * @dev Mint shares for deposits accumulated, effectively including their owners in the next round.
     * `processQueuedDeposits` extracts up to but not including endIndex. For example, processQueuedDeposits(1,4)
     * extracts the second element through the fourth element (elements indexed 1, 2, and 3).
     *
     * @param startIndex Zero-based index at which to start processing deposits
     * @param endIndex The index of the first element to exclude from queue
     */
    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) public {
        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();

        uint256 processedDeposits;
        for (uint256 i = startIndex; i < endIndex; i++) {
            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);
            uint256 shares = _mintShares(depositEntry.owner, depositEntry.amount, processedDeposits);
            processedDeposits += depositEntry.amount;
            emit DepositProcessed(depositEntry.owner, currentRoundId, depositEntry.amount, shares);
        }
        depositQueue.remove(startIndex, endIndex);
    }

    /** Internals **/

    /**
     * @dev Mint new shares, effectively representing user participation in the Vault.
     */
    function _mintShares(
        address owner,
        uint256 assets,
        uint256 processedDeposits
    ) internal virtual returns (uint256 shares) {
        shares = assets;
        processedDeposits += totalAssets();

        if (totalShares > 0) {
            shares = assets.mulDivUp(totalShares, processedDeposits);
        }

        userShares[owner] += shares;
        totalShares += shares;
    }

    /**
     * @dev Burn shares.
     * @param owner Address owner of the shares
     * @param shares Amount of shares to lock
     */
    function _burnShares(address owner, uint256 shares) internal virtual returns (uint256 claimableUnderlying) {
        if (shares > userShares[owner]) revert IVault__CallerHasNotEnoughShares();
        claimableUnderlying = userShares[owner].mulDivDown(totalAssets(), totalShares);
        userShares[owner] -= shares;
        totalShares -= shares;
    }

    /**
     * @dev Spend allowance on behalf of the shares owner.
     * @param owner Address owner of the shares
     * @param spender Address shares spender
     * @param shares Amount of shares to spend
     */
    function _useAllowance(
        address owner,
        address spender,
        uint256 shares
    ) internal {
        uint256 allowed = _allowances[owner][spender];
        if (shares > allowed) revert IVault__SharesExceedAllowance();

        if (allowed != type(uint256).max) {
            _allowances[owner][spender] = allowed - shares;
        }
    }

    /** Hooks **/

    // solhint-disable-next-line no-empty-blocks
    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}

    // solhint-disable-next-line no-empty-blocks
    function _afterRoundStart(uint256 assets) internal virtual {}

    // solhint-disable-next-line no-empty-blocks
    function _afterRoundEnd() internal virtual {}
}
